<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. Error Handling &#8212; Advanced Message Processing System (AMPS) C++ Developer Guide develop
 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'develop',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. State of the World" href="sow.html" />
    <link rel="prev" title="4. Subscriptions" href="subscriptions.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/flag_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. Error Handling</a><ul>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li><a class="reference internal" href="#exception-types">Exception Types</a></li>
<li><a class="reference internal" href="#command-timeout">Command Timeout</a></li>
<li><a class="reference internal" href="#exception-handling-and-asynchronous-message-processing">Exception Handling and Asynchronous Message Processing</a></li>
<li><a class="reference internal" href="#controlling-blocking-with-command-timeout">Controlling Blocking With Command Timeout</a></li>
<li><a class="reference internal" href="#disconnect-handling">Disconnect Handling</a><ul>
<li><a class="reference internal" href="#using-a-heartbeat-to-detect-disconnection">Using a Heartbeat to Detect Disconnection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unexpected-messages">Unexpected Messages</a></li>
<li><a class="reference internal" href="#unhandled-exceptions">Unhandled Exceptions</a></li>
<li><a class="reference internal" href="#detecting-write-failures">Detecting Write Failures</a></li>
<li><a class="reference internal" href="#monitoring-connection-state">Monitoring Connection State</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="subscriptions.html" title="previous chapter">4. Subscriptions</a></li>
      <li>Next: <a href="sow.html" title="next chapter">6. State of the World</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="error-handling">
<h1>5. Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h1>
<p>In every distributed system, the robustness of your application depends
on its ability to recover gracefully from unexpected events. The AMPS
client provides the building blocks necessary to ensure your application
can recover from the kinds of errors and special events that may occur
when using AMPS.</p>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<p>Generally speaking, when an error occurs that prohibits an operation
from succeeding, AMPS will throw an exception. AMPS exceptions
universally derive from <code class="docutils literal"><span class="pre">AMPS::AMPSException</span></code>, so by catching
<code class="docutils literal"><span class="pre">AMPSException</span></code>, you will be sure to catch anything AMPS throws. For
example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">void</span> <span class="n">ReadAndEvaluate</span><span class="p">(</span><span class="n">Client</span><span class="o">&amp;</span> <span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* read a new payload from the user */</span>
    <span class="n">string</span> <span class="n">payload</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

    <span class="cm">/* write a new message to AMPS */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">client</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="s">&quot;UserMessage&quot;</span><span class="p">,</span>
            <span class="n">string</span><span class="p">(</span><span class="s">&quot;{ </span><span class="se">\&quot;</span><span class="s">message</span><span class="se">\&quot;</span><span class="s"> : </span><span class="se">\&quot;</span><span class="s">data</span><span class="se">\&quot;</span><span class="s"> }&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">AMPSException</span><span class="o">&amp;</span> <span class="n">exception</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;An AMPS exception occurred: &quot;</span><span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, if an error occurs the program writes the error to
<code class="docutils literal"><span class="pre">stderr</span></code>, and the <code class="docutils literal"><span class="pre">publish()</span></code> command fails. However, <code class="docutils literal"><span class="pre">client</span></code> is
still usable for continued publishing and subscribing. When the error
occurs, the exception is written to the console, converting the
exception to a string via the <code class="docutils literal"><span class="pre">toString()</span></code> method.</p>
<p>AMPS exception types vary based on the nature of the error that occurs.
In your program, if you would like to handle certain kinds of errors
differently than others, you can <code class="docutils literal"><span class="pre">catch</span></code> the appropriate subclass of
<code class="docutils literal"><span class="pre">AMPSException</span></code> to detect those specific errors and do something
different.</p>
<div class="highlight-cpp" id="exceptions-subclass-handling"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="nf">CreateNewSubscription</span><span class="p">(</span><span class="n">Client</span><span class="o">&amp;</span> <span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">topicName</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">topicName</span> <span class="o">=</span> <span class="n">AskUserForTopicName</span><span class="p">();</span>

        <span class="k">try</span>
        <span class="p">{</span>
            <span class="cm">/* If an error occurs when setting up the subscription whether or not to try again</span>
<span class="cm">             * based on the subclass of AMPSException that is thrown. If a</span>
<span class="cm">             * BadRegexTopicException, this exception is thrown during subscription to indicate</span>
<span class="cm">             * that a bad regular expression was supplied, so we would like to give the user a</span>
<span class="cm">             * chance to correct.</span>
<span class="cm">             */</span>
            <span class="n">id</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">HandleMessage</span><span class="p">,</span>
            <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">),</span>
            <span class="n">topicName</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">BadRegexTopicException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* This line indicates that the program catches the BadRegexTopicException</span>
<span class="cm">             * exception and displays a specific error to the user indicating the topic name or</span>
<span class="cm">             * expression was invalid. By not returning from the function in this catch block,</span>
<span class="cm">             * the while loop runs again and the user is asked for another topic name.</span>
<span class="cm">             * we’ll ask the user for another topic</span>
<span class="cm">             */</span>
            <span class="n">DisplayError</span><span class="p">(</span><span class="s">&quot;Error: bad topic name or regular &quot;</span> <span class="o">+</span>
                         <span class="s">&quot;expression ’&quot;</span> <span class="o">+</span> <span class="n">topicName</span> <span class="o">+</span><span class="s">&quot;’. &quot;</span> <span class="o">+</span>
                         <span class="s">&quot;The error was: &quot;</span> <span class="o">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="cm">/* If an AMPS exception of a type other than BadRegexTopicException is thrown by</span>
<span class="cm">         * AMPS, it is caught here. In that case, the program emits a different error</span>
<span class="cm">         * message to the user.</span>
<span class="cm">         */</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">AMPSException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DisplayError</span><span class="p">(</span><span class="s">&quot;Error: error setting up subscription &quot;</span> <span class="o">+</span>
                         <span class="s">&quot;to topic &quot;</span> <span class="o">+</span> <span class="n">topicName</span> <span class="o">+</span>
                         <span class="s">&quot;. The error was: &quot;</span> <span class="o">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>

        <span class="cm">/* At this point the code stops attempting to subscribe to the client by the return</span>
<span class="cm">         * NULL statement.</span>
<span class="cm">         */</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// give up</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example 5.1:</strong> <em>Catching AMPSException Subclasses</em></p>
</div>
<div class="section" id="exception-types">
<h2>Exception Types<a class="headerlink" href="#exception-types" title="Permalink to this headline">¶</a></h2>
<p>Each method in AMPS documents the kinds of exceptions that it can throw.
For reference, <a class="reference internal" href="exceptions.html#exceptions-table"><span class="std std-ref">Table 1.A:</span></a> contains a list of all
of the exception types you may encounter while using AMPS, when they
occur, and what they mean.</p>
</div>
<div class="section" id="command-timeout">
<h2>Command Timeout<a class="headerlink" href="#command-timeout" title="Permalink to this headline">¶</a></h2>
<p>The named convenience methods and the <code class="docutils literal"><span class="pre">Command</span></code> class provide a
<code class="docutils literal"><span class="pre">timeout</span></code> setting that specifies how long the command should wait
to receive a <code class="docutils literal"><span class="pre">processed</span></code> acknowledgment from AMPS. This can be helpful
in cases where it is important for the caller to limit the amount of time
to block waiting for AMPS to acknowledge the command. If the AMPS client
does not receive the processed acknowledgment within the specified
time, the client sends an <code class="docutils literal"><span class="pre">unsubscribe</span></code> command to the server to
cancel the command and throws an exception.</p>
<p>Acknowledgments from AMPS are processed by the client receive thread
on the same socket as data from AMPS. This means that any other data
previously returned (such as the results of a large query) must be
consumed before the acknowledgment can be processed. An application
that submits a set of SOW queries in rapid succession should set a
timeout that takes into account the amount of time required to
process the results of the previous query.</p>
</div>
<div class="section" id="exception-handling-and-asynchronous-message-processing">
<h2>Exception Handling and Asynchronous Message Processing<a class="headerlink" href="#exception-handling-and-asynchronous-message-processing" title="Permalink to this headline">¶</a></h2>
<p>When using asynchronous message processing, exceptions thrown from the
message handler are silently absorbed by the AMPS C++ client by default.
The AMPS C++ client allows you to register an exception listener to
detect and respond to these exceptions. When an exception listener is
registered, AMPS will call the exception listener with the exception.
See <a class="reference internal" href="#error-handling-exception-listener"><span class="std std-ref">Chapter 5</span></a> for details.</p>
</div>
<div class="section" id="controlling-blocking-with-command-timeout">
<h2>Controlling Blocking With Command Timeout<a class="headerlink" href="#controlling-blocking-with-command-timeout" title="Permalink to this headline">¶</a></h2>
<p>The named convenience methods and the <code class="docutils literal"><span class="pre">Command</span></code> class provide a
<code class="docutils literal"><span class="pre">timeout</span></code> setting that specifies how long the command should wait
to receive a <code class="docutils literal"><span class="pre">processed</span></code> acknowledgment from AMPS. This can be helpful
in cases where it is important for the caller to limit the amount of time
to block waiting for AMPS to acknowledge the command. If the AMPS client
does not receive the processed acknowledgment within the specified
time, the client sends an <code class="docutils literal"><span class="pre">unsubscribe</span></code> command to the server to
cancel the command and throws an exception.</p>
<p>Acknowledgments from AMPS are processed by the client receive thread
on the same socket as data from AMPS. This means that any other data
previously returned (such as the results of a large query) must be
consumed before the acknowledgment can be processed. An application
that submits a set of SOW queries in rapid succession should set a
timeout that takes into account the amount of time required to
process the results of the previous query.</p>
</div>
<div class="section" id="disconnect-handling">
<h2>Disconnect Handling<a class="headerlink" href="#disconnect-handling" title="Permalink to this headline">¶</a></h2>
<p>Every distributed system will experience occasional disconnections
between one or more nodes. The reliability of the overall system depends
on an application’s ability to efficiently detect and recover from these
disconnections. Using the AMPS C/C++ client’s disconnect handling, you
can build powerful applications that are resilient in the face of
connection failures and spurious disconnects.</p>
<p>The <code class="docutils literal"><span class="pre">HAClient</span></code> class, included with the AMPS C++ client, contains a
disconnect handler and other features for building highly-available
applications. The <code class="docutils literal"><span class="pre">HAClient</span></code> includes features for managing a list of
failover servers, resuming subscriptions, republishing in-flight
messages, and other functionality that is commonly needed for high
availability. 60East recommends using the <code class="docutils literal"><span class="pre">HAClient</span></code> for automatic
reconnection wherever possible, as the HAClient disconnect handler has
been carefully crafted to handle a wide variety of edge cases and
potential failures. This section covers the use of a custom disconnect
handler in the event that the behavior of the <code class="docutils literal"><span class="pre">HAClient</span></code> does not suit
the needs of your application.</p>
<p>Custom disconnect handling gives you the ultimate in control and
flexibility regarding how to respond to disconnects. Your application
gets to specify exactly what happens when a disconnect occurs by
supplying a function to <code class="docutils literal"><span class="pre">client.setDisconnectHandler()</span></code>, which is
invoked whenever a disconnect occurs.</p>
<p><a class="reference internal" href="#error-handling-disconnect-handler"><span class="std std-ref">Example 5.2</span></a>
shows the basics:</p>
<div class="highlight-cpp" id="error-handling-disconnect-handler"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyApp</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">_uri</span><span class="p">;</span>
    <span class="n">Client</span> <span class="n">_client</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">MyApp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">uri</span><span class="p">)</span> <span class="o">:</span> <span class="n">_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">),</span> <span class="n">_client</span><span class="p">(</span><span class="s">&quot;myapp&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_uri</span> <span class="o">=</span> <span class="n">uri</span><span class="p">;</span>

        <span class="cm">/* setDisconnectHandler() method is called to supply a function for use when AMPS</span>
<span class="cm">         * detects a disconnect. At any time, this function may be called by AMPS to</span>
<span class="cm">         * indicate that the client has disconnected from the server, and to allow your</span>
<span class="cm">         * application to choose what to do about it. The application continues on to</span>
<span class="cm">         * connect and subscribe to the orders topic.</span>
<span class="cm">         */</span>
        <span class="n">_client</span><span class="p">.</span><span class="n">setDisconnectHandler</span><span class="p">(</span><span class="n">AttemptReconnection</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="k">this</span><span class="p">);</span>
        <span class="n">_client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">uri</span><span class="p">);</span>
        <span class="n">_client</span><span class="p">.</span><span class="n">logon</span><span class="p">();</span>
        <span class="n">_client</span><span class="p">.</span><span class="n">execute_async</span><span class="p">(</span><span class="n">Command</span><span class="p">(</span><span class="s">&quot;subscribe&quot;</span><span class="p">)</span>
                                <span class="p">.</span><span class="n">setTopic</span><span class="p">(</span><span class="s">&quot;orders&quot;</span><span class="p">),</span>
                              <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyApp</span><span class="o">::</span><span class="n">ShowMessage</span><span class="p">,</span>
                                    <span class="k">this</span><span class="p">,</span>
                                    <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">ShowMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* display order data to the user */</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="cm">/* Our disconnect handler’s implementation begins here. In this example, we simply</span>
<span class="cm">     * try to reconnect to the original server. A more robust reconnect would have</span>
<span class="cm">     * logic to limit either the total number of connects, frequency of connects or</span>
<span class="cm">     * both. Errors are likely to occur here, therefore we must have disconnected for a</span>
<span class="cm">     * reason, but Client takes care of catching errors from our disconnect handler. If</span>
<span class="cm">     * an error occurs in our attempt to reconnect and an exception is thrown by</span>
<span class="cm">     * connect(), then Client will catch it and absorb it, passing it to the</span>
<span class="cm">     * ExceptionListener if registered. If the client is not connected by the time the</span>
<span class="cm">     * disconnect handler returns, AMPS throws DisconnectedException.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">AttemptReconnection</span><span class="p">(</span><span class="n">Client</span><span class="o">&amp;</span> <span class="n">client</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">userdata</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MyApp</span><span class="o">*</span> <span class="n">app</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyApp</span><span class="o">*</span><span class="p">)</span> <span class="n">userdata</span><span class="p">;</span>
        <span class="cm">/* simple: just try to reconnect once. */</span>
        <span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">_uri</span><span class="p">);</span>
        <span class="n">client</span><span class="p">.</span><span class="n">logon</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example 5.2:</strong> <em>Supplying a disconnect handler</em></p>
<p>By creating a more advanced disconnect handler, you can implement logic
to make your application even more robust. For example, imagine you have
a group of AMPS servers configured for high availability—you could
implement fail-over by simply trying the next server in the list until
one is found.
<a class="reference internal" href="#error-handling-client-failover"><span class="std std-ref">Example 5.3</span></a>
shows a brief example.</p>
<div class="highlight-cpp" id="error-handling-client-failover"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyApp</span>
<span class="p">{</span>

    <span class="cm">/* Here our application is configured with a vector of AMPS server URIs to choose</span>
<span class="cm">     * from, instead of a single URI. These will be used in the ConnectToNextUri()</span>
<span class="cm">     * method as explained below.</span>
<span class="cm">     */</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">_uris</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_currentUri</span><span class="p">;</span>
    <span class="n">Client</span> <span class="n">_client</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">MyApp</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">uris</span><span class="p">)</span> <span class="o">:</span> <span class="n">_uris</span><span class="p">(</span><span class="n">uris</span><span class="p">),</span> <span class="n">_currentUri</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_client</span><span class="p">(</span><span class="s">&quot;MyApp&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* ConnectToNextUri() is invoked by our disconnect handler TestDisconnectHandler in</span>
<span class="cm">         * the AMPS Client when a disconnect occurs. Since our client is currently</span>
<span class="cm">         * disconnected, we manually invoke our disconnect handler to initiate the first</span>
<span class="cm">         * connection.</span>
<span class="cm">         */</span>
        <span class="n">_client</span><span class="p">.</span><span class="n">setDisconnectHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ConnectToNextUri</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="n">ConnectToNextUri</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">ConnectToNextUri</span><span class="p">(</span><span class="n">Client</span> <span class="n">client</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">me</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MyApp</span><span class="o">*</span> <span class="n">app</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyApp</span><span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">;</span>

        <span class="cm">/* During a disconnect the AMPS Client invokes ConnectToNextUri(), which loops</span>
<span class="cm">         * around our array of URIs attempting to connect to each one until successful. In</span>
<span class="cm">         * the invoke() method it attempts to connect to the current URI, and if it is</span>
<span class="cm">         * successful, returns immediately. If the connection attempt fails, the exception</span>
<span class="cm">         * handler for AMPSException is invoked. In the exception handler, we advance to</span>
<span class="cm">         * the next URI, display a warning message, and continue around the loop. This</span>
<span class="cm">         * simplistic handler never gives up, but in a typical implementation, you would</span>
<span class="cm">         * likely stop attempting to reconnect at some point.</span>
<span class="cm">         */</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">_uris</span><span class="p">[</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">_currentUri</span><span class="p">]);</span>
                <span class="cm">/* At this point the client registers a subscription to the server we have</span>
<span class="cm">                 * connected to. It is important to note that, once a new server is connected, it</span>
<span class="cm">                 * is the responsibility of the application to re-establish any subscriptions</span>
<span class="cm">                 * placed previously. This behavior provides an important benefit to your</span>
<span class="cm">                 * application: one reason for disconnect is due to a client’s inability to keep up</span>
<span class="cm">                 * with the rate of message flow. In a more advanced disconnect handler, you could</span>
<span class="cm">                 * choose to not re-establish subscriptions that are the cause of your</span>
<span class="cm">                 * application’s demise.</span>
<span class="cm">                 */</span>
                <span class="n">client</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(...);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">catch</span><span class="p">(</span><span class="n">AMPSException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">app</span><span class="o">-&gt;</span><span class="n">_currentUri</span> <span class="o">=</span> <span class="p">(</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">_currentUri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">_uris</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example 5.3:</strong> <em>Simple client failover implementation</em></p>
<div class="section" id="using-a-heartbeat-to-detect-disconnection">
<h3>Using a Heartbeat to Detect Disconnection<a class="headerlink" href="#using-a-heartbeat-to-detect-disconnection" title="Permalink to this headline">¶</a></h3>
<p>The AMPS client includes a heartbeat feature to help applications detect
disconnection from the server within a predictable amount of time.
Without using a heartbeat, an application must rely on the operating
system to notify the application when a disconnect occurs. For
applications that are simply receiving messages, it can be impossible to
tell whether a socket is disconnected or whether there are simply no
incoming messages for the client.</p>
<p>When you set a heartbeat, the AMPS client sends a heartbeat message to
the AMPS server at a regular interval, and waits a specified amount of
time for the response. If the operating system reports an error on send,
or if there is no message received from the server within the specified
amount of time, the AMPS client considers the server to be disconnected.
Likewise, the server will ensure that traffic is sent to the client
at the specified interval, using heartbeat messages when no other traffic
is being sent to the client. If, after sending a heartbeat message, no
traffic from the client arrives within a period twice the specified
interval, the server will consider the client to be disconnected or
nonresponsive.</p>
<p>The AMPS client processes heartbeat messages on the client receive
thread, which is the thread used for asynchronous message processing. If
your application uses asynchronous message processing and occupies the
thread for longer than the heartbeat interval, the client may fail to
respond to heartbeat messages in a timely manner and may be disconnected
by the server.</p>
</div>
</div>
<div class="section" id="unexpected-messages">
<h2>Unexpected Messages<a class="headerlink" href="#unexpected-messages" title="Permalink to this headline">¶</a></h2>
<p>The AMPS C++ client handles most incoming messages and takes appropriate
action. Some messages are unexpected or occur only in very rare
circumstances. The AMPS C++ client provides a way for clients to process
these messages. Rather than providing handlers for all of these unusual
events, AMPS provides a single handler function for messages that can&#8217;t
be handled during normal processing.</p>
<p>Your application registers this handler by setting the
<code class="docutils literal"><span class="pre">UnhandledMessageHandler</span></code> for the client. This handler is called when
the client receives a message that can&#8217;t be processed by any other
handler. This is a rare event, and typically indicates an unexpected
condition.</p>
<p>For example, if a client publishes a message that AMPS cannot parse,
AMPS returns a failure acknowledgment. This is an unexpected event, so
AMPS does not include an explicit handler for this event, and failure
acknowledgments are received in the method registered as the
<code class="docutils literal"><span class="pre">UnhandledMessageHandler</span></code>.</p>
<p>Your application is responsible for taking any corrective action needed.
For example, if a message publication fails, your application can decide
to republish the message, publish a compensating message, log the error,
stop publication altogether, or any other action that is appropriate.</p>
</div>
<div class="section" id="unhandled-exceptions">
<span id="error-handling-exception-listener"></span><h2>Unhandled Exceptions<a class="headerlink" href="#unhandled-exceptions" title="Permalink to this headline">¶</a></h2>
<p>In the AMPS C++ client, exceptions can occur that are not thrown to the
main thread of the application. For example, when an exception is thrown
from a message handler running on a background thread, AMPS does not
automatically propagate that exception to the main thread.</p>
<p>Instead, AMPS provides the exception to an unhandled exception handler
if one is specified on the client. The unhandled exception handler
receives a reference to the exception object, and takes whatever action
is necessary. Typically, this involves logging the exception or setting
an error flag that the main thread can act on. Notice that AMPS C++
client only catches exceptions that derive from <code class="docutils literal"><span class="pre">std::exception</span></code>. If
your message handler contains code that can throw exceptions that do not
derive from <code class="docutils literal"><span class="pre">std::exception</span></code>, 60East recommends catching these
exceptions and throwing an equivalent exception that derives from
<code class="docutils literal"><span class="pre">std::exception</span></code>.</p>
<p>If your application will attempt to recover from an exception
thrown on the background processing thread, your application should
set a flag and attempt recovery on a <em>different</em> thread than the
thread that called the exception listener.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">At the point that the AMPS client calls the exception listener,
it has handled the exception. Your exception listener must
not rethrow the exception (or wrap the exception and throw
a different exception type).</p>
</div>
<p>For example, the unhandled exception handler below takes a
<code class="docutils literal"><span class="pre">std::ostream</span></code>, and logs information from each exception to that
<code class="docutils literal"><span class="pre">std::ostream</span></code>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExceptionLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AMPS</span><span class="o">::</span><span class="n">ExceptionListener</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="n">ExceptionLogger</span><span class="p">()</span> <span class="o">:</span> <span class="n">os_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ExceptionLogger</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="o">:</span> <span class="n">os_</span><span class="p">(</span><span class="n">os</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">exceptionThrown</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
       <span class="n">os_</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="detecting-write-failures">
<h2>Detecting Write Failures<a class="headerlink" href="#detecting-write-failures" title="Permalink to this headline">¶</a></h2>
<p id="index-0">The <code class="docutils literal"><span class="pre">publish</span></code> methods in the C++ client deliver the
message to be published to AMPS and then return immediately, without
waiting for AMPS to return an acknowledgment. Likewise, the
<code class="docutils literal"><span class="pre">sowDelete</span></code> methods request deletion of SOW messages, and return
before AMPS processes the message and performs the deletion. This
approach provides high performance for operations that are unlikely to
fail in production. However, this means that the methods return before
AMPS has processed the command, without the ability to return an error
in the event that the command fails.</p>
<p>The AMPS C++ client provides a <code class="docutils literal"><span class="pre">FailedWriteHandler</span></code> that is called
when the client receives an acknowledgment that indicates a failure to
persist data within AMPS. To use this functionality, you implement the
<code class="docutils literal"><span class="pre">FailedWriteHandler</span></code> interface, construct an instance of your new
class, and register that instance with the <code class="docutils literal"><span class="pre">setFailedWriteHandler()</span></code>
function on the client. When an acknowledgment returns that indicates a
failed write, AMPS calls the registered handler method with information
from the acknowledgment message, supplemented with information from the
client publish store if one is available. Your client can log this
information, present an error to the user, or take whatever action is
appropriate for the failure.</p>
<p>If your application needs to know whether publishes succeeded and
are durably persisted, the following approach is recommended:</p>
<ul class="simple">
<li>Set a <code class="docutils literal"><span class="pre">PublishStore</span></code> on the client. This will ensure that messages
are retransmitted if the client becomes disconnected before the
message is acknowledged <em>and</em> request <code class="docutils literal"><span class="pre">persisted</span></code> acknowledgments
for messages.</li>
<li>Install a <code class="docutils literal"><span class="pre">FailedWriteHandler</span></code>. In the event that AMPS reports
an error for a given message, that event will be reported to
the <code class="docutils literal"><span class="pre">FailedWriteHandler</span></code>.</li>
<li>Call <code class="docutils literal"><span class="pre">publishFlush()</span></code> and verify that all messages are
persisted before the application exits.</li>
</ul>
<p>When no <code class="docutils literal"><span class="pre">FailedWriteHandler</span></code> is registered, acknowledgments that
indicate errors in persisting data are treated as unexpected messages
and routed to the <code class="docutils literal"><span class="pre">LastChanceMessageHandler</span></code>. In this case, AMPS
provides only the acknowledgment message and does not provide the
additional information from the client publish store.</p>
</div>
<div class="section" id="monitoring-connection-state">
<h2>Monitoring Connection State<a class="headerlink" href="#monitoring-connection-state" title="Permalink to this headline">¶</a></h2>
<p>The AMPS client interface provides the ability to set one or more connection
state listeners. A connection state listener is a callback that is invoked
when the AMPS client detects a change to the connection state.</p>
<p>A connection state listener may be called from the client receive thread.
An application should not submit commands to AMPS from a connection
state listener, or the application risks creating a deadlock for
commands that wait for acknowledgement from the server.</p>
<p>The AMPS client provides the following state values for a connection state
listener:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">State</th>
<th class="head">Indicates</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Connected</td>
<td><p class="first">The client has established a connection to
AMPS. If you are using a <code class="docutils literal"><span class="pre">Client</span></code>, this
is delivered when <code class="docutils literal"><span class="pre">connect()</span></code> is successful.</p>
<p>If you are using an <code class="docutils literal"><span class="pre">HAClient</span></code>, this state
indicates that the <code class="docutils literal"><span class="pre">connect</span></code> part of the
connect and logon process has completed.
An <code class="docutils literal"><span class="pre">HAClient</span></code> using the default disconnect
handler will attempt to log on immediately after
delivering this state.</p>
<p>Most applications that use <code class="docutils literal"><span class="pre">Client</span></code> will
attempt to log on immediately after the call to
<code class="docutils literal"><span class="pre">connect()</span></code> returns.</p>
<p class="last">An application should not submit commands to
AMPS from the connection state listener
while the client is in this state <em>unless</em>
the application knows that the state has been
delivered from a <code class="docutils literal"><span class="pre">Client</span></code> and that the
<code class="docutils literal"><span class="pre">Client</span></code> does not call <code class="docutils literal"><span class="pre">logon()</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td>LoggedOn</td>
<td><p class="first">The client has successfully logged on to
AMPS. If you are using a <code class="docutils literal"><span class="pre">Client</span></code>, this
is delivered when <code class="docutils literal"><span class="pre">logon()</span></code> is successful.</p>
<p>If you are using an <code class="docutils literal"><span class="pre">HAClient</span></code>, this state
indicates that the <code class="docutils literal"><span class="pre">logon</span></code> part of the
connect and logon process has completed.</p>
<p class="last">This state is delivered after the client is
logged on, but before recovery of client state
is complete. Recovery will continue after
delivering this state: the application should
not submit commands to AMPS from the connection
state listener while the client
is in this state if further recovery will take
place.</p>
</td>
</tr>
<tr class="row-even"><td>HeartbeatInitiated</td>
<td><p class="first">The client has successfully started heartbeat
monitoring with AMPS. This state is delivered
if the application has enabled heartbeating
on the client.</p>
<p class="last">This state is delivered before recovery of the
client state is complete. Recovery may continue
after this state is delivered. The application
should not submit commands to AMPS from the
connection state listener until the
client is completely recovered.</p>
</td>
</tr>
<tr class="row-odd"><td>PublishReplayed</td>
<td><p class="first">Delivered when a client has completed replay
of the publish store when recovering after
connecting to AMPS.</p>
<p>This state is delivered when the client has a
PublishStore configured.</p>
<p class="last">If the client has a subscription manager set,
(which is the default for an <code class="docutils literal"><span class="pre">HAClient</span></code>), the
application should not submit commands from
from the connection state listener
until the <code class="docutils literal"><span class="pre">Resubscribed</span></code> state is received.</p>
</td>
</tr>
<tr class="row-even"><td>Resubscribed</td>
<td><p class="first">Delivered when a client has re-entered
subscriptions when recovering after connecting
to AMPS.</p>
<p class="last">This state is delivered when the client has a
subscription manager set (which is the default
for an <code class="docutils literal"><span class="pre">HAClient</span></code>). This is the final recovery
step. An application can submit commands to
AMPS from the connection state listener
after receiving this state.</p>
</td>
</tr>
<tr class="row-odd"><td>Disconnected</td>
<td>The client is not connected. For an
<code class="docutils literal"><span class="pre">HAClient</span></code>, this means that the client will
attempt to reconnect to AMPS. For a <code class="docutils literal"><span class="pre">Client</span></code>,
this means that the client will invoke the
disconnect handler, if one is specified.</td>
</tr>
<tr class="row-even"><td>Shutdown</td>
<td>The client is shut down. For an <code class="docutils literal"><span class="pre">HAClient</span></code>,
this means that the client will no longer
attempt to reconnect to AMPS. This state is
delivered when <code class="docutils literal"><span class="pre">close()</span></code> is called on the
client or when a server chooser tells the
<code class="docutils literal"><span class="pre">HAClient</span></code> to stop reconnecting to AMPS.</td>
</tr>
</tbody>
</table>
<p><strong>Table 5.1:</strong> <em>ConnectionStateListener values</em></p>
<p>The enumeration provided for the connection state listener also includes
a value of <code class="docutils literal"><span class="pre">UNKNOWN</span></code>, for use as a default or to represent additional
states in a custom <code class="docutils literal"><span class="pre">Client</span></code> implementation. The 60East implementations
of the client do not deliver this state.</p>
<p>The following table shows examples of the set of states that will be delivered
during connection, in order, depending on what features
of the client are set. Notice that, for an instance of the <code class="docutils literal"><span class="pre">Client</span></code> class,
this table assumes that the application calls both <code class="docutils literal"><span class="pre">connect()</span></code> and
<code class="docutils literal"><span class="pre">logon()</span></code>. For an <code class="docutils literal"><span class="pre">HAClient</span></code>, this table assumes that the <code class="docutils literal"><span class="pre">HAClient</span></code> is
using the default <code class="docutils literal"><span class="pre">DisconnectHandler</span></code> for the <code class="docutils literal"><span class="pre">HAClient</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Configuration</th>
<th class="head">States</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first">subscription manager</p>
<p class="last">publish store</p>
</td>
<td><p class="first">Connected</p>
<p>LoggedOn</p>
<p>PublishReplayed</p>
<p class="last">Resubscribed</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first">subscription manager</p>
<p>publish store</p>
<p class="last">heartbeat set</p>
</td>
<td><p class="first">Connected</p>
<p>LoggedOn</p>
<p>HeartbeatInitiated</p>
<p>PublishReplayed</p>
<p class="last">Resubscribed</p>
</td>
</tr>
<tr class="row-even"><td>subscription manager</td>
<td><p class="first">Connected</p>
<p>LoggedOn</p>
<p class="last">Resubscribed</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first">subscription manager</p>
<p class="last">heartbeat set</p>
</td>
<td><p class="first">Connected</p>
<p>LoggedOn</p>
<p>HeartbeatInitiated</p>
<p class="last">Resubscribed</p>
</td>
</tr>
<tr class="row-even"><td><dl class="first last docutils">
<dt>(default <code class="docutils literal"><span class="pre">Client</span></code></dt>
<dd>configuration)</dd>
</dl>
</td>
<td><p class="first">Connected</p>
<p class="last">LoggedOn</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Table 5.2:</strong> <em>Sequence of states for connection</em></p>
</div>
</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, 60East Technologies, Inc.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>