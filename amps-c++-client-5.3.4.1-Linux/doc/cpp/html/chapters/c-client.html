<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>11. Using the AMPS C Client &#8212; Advanced Message Processing System (AMPS) C++ Developer Guide develop
 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'develop',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Utilities" href="utilities.html" />
    <link rel="prev" title="10. AMPS Programming: Working with Commands" href="creating-commands.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/flag_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">11. Using the AMPS C Client</a><ul>
<li><a class="reference internal" href="#c-client-functionality">C Client Functionality</a></li>
<li><a class="reference internal" href="#when-to-use-the-c-client">When to Use the C Client</a></li>
<li><a class="reference internal" href="#error-handing-in-the-c-client">Error Handing in the C Client</a></li>
<li><a class="reference internal" href="#c-client-samples">C Client Samples</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="creating-commands.html" title="previous chapter">10.  AMPS Programming: Working with Commands</a></li>
      <li>Next: <a href="utilities.html" title="next chapter">12. Utilities</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-the-amps-c-client">
<h1>11. Using the AMPS C Client<a class="headerlink" href="#using-the-amps-c-client" title="Permalink to this headline">Â¶</a></h1>
<p>The AMPS C/C++ client is built in two layers: the C layer that exposes lower-level
primitives for sending and receiving messages to AMPS, and the C++ layer providing
a set of abstractions over the C layer that makes it easier to work with AMPS and
create robust applications. The C++ layer is recommended for many applications,
since it offers a good balance of performance, control, and ease of use. If you
are integrating AMPS into an environment that cannot host a C runtime, or if
you need extremely fine-grained control over how your application interacts
with AMPS, then you may choose to use the C layer directly.</p>
<p>The C Client offers low-level functionality for working with AMPS. With the C
client, your application is responsible for correctly assembling the parameters
to each command to AMPS and interpreting the response from AMPS. The C client does
not provide higher-level abstractions such as publish stores, automatic failover
and reconnection, sequence number management for published messages, and so on.
Instead, you build the capabilities that your application needs over the low
level primitives.</p>
<p>As an example,
<a class="reference internal" href="#connecting-in-c"><span class="std std-ref">Example 11.1</span></a>
shows a basic example written to use the C layer directly:</p>
<div class="highlight-cpp" id="connecting-in-c"><span id="index-0"></span><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;amps/amps.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* At this point in the program, the necessary objects are declared</span>
<span class="cm">     * in order to permit interaction with AMPS. When AMPS errors occur,</span>
<span class="cm">     * their text is available through the amps_client_get_error() function,</span>
<span class="cm">     * so it is here that we will create a small char array to hold the errors.</span>
<span class="cm">     */</span>
    <span class="kt">char</span> <span class="n">errorBuffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">clientName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="cm">/* Here an amps_handle is declared for each object and message objects</span>
<span class="cm">     * that are constructed later. An amps_handle is an opaque handle to</span>
<span class="cm">     * an object constructed by AMPS, which cannot be dereferenced or used</span>
<span class="cm">     * by means other than AMPS functions. amps_handle is the size of</span>
<span class="cm">     * a pointer (that is, sizeof(void*) )and may be passed by value</span>
<span class="cm">     * wherever needed.</span>
<span class="cm">     *</span>
<span class="cm">     * Notice that these handles are not yet initialized. The program will</span>
<span class="cm">     * initialize them as it needs to use them.</span>
<span class="cm">     */</span>
    <span class="n">amps_handle</span> <span class="n">client</span><span class="p">;</span>
    <span class="n">amps_handle</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">amps_handle</span> <span class="n">logon_command</span><span class="p">;</span>

    <span class="cm">/* Next we declare an amps_result object, which is used to store the</span>
<span class="cm">     * return value from functions that may fail, such as during connection or</span>
<span class="cm">     * interaction with an AMPS server. Many AMPS functions return an</span>
<span class="cm">     * amps_results.</span>
<span class="cm">     */</span>
    <span class="n">amps_result</span> <span class="n">result</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * AMPS clients should be constructed with a unique name that is</span>
<span class="cm">     * consistent for each logical instance of the application.</span>
<span class="cm">     *</span>
<span class="cm">     * For sample purposes, we omit constructing the name and</span>
<span class="cm">     * assume that generate_client_name() fills in the clientName</span>
<span class="cm">     * array with an appropriate value.</span>
<span class="cm">     */</span>

    <span class="n">generate_client_name</span><span class="p">(</span><span class="n">clientName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientName</span><span class="p">));</span>

    <span class="cm">/* Here we construct our AMPS client with the unique, consistent name</span>
<span class="cm">     * generated earlier. The initializes the client variable declared</span>
<span class="cm">     * earlier.</span>
<span class="cm">     *</span>
<span class="cm">     * This function allocates resources that must be freed, and can only be</span>
<span class="cm">     * freed by a corresponding call to amps_client_destroy.</span>
<span class="cm">     */</span>

    <span class="n">client</span> <span class="o">=</span> <span class="n">amps_client_create</span><span class="p">(</span><span class="n">clientName</span><span class="p">);</span>

    <span class="cm">/* This is how a connection is established; control continues to</span>
<span class="cm">     * where the AMPS message is allocated.</span>
<span class="cm">     */</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">amps_client_connect</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s">&quot;tcp://localhost:9007/amps/json&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">AMPS_E_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">amps_client_get_error</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errorBuffer</span><span class="p">));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">);</span>
        <span class="cm">/* Since the client was previously created,</span>
<span class="cm">         * it must be destroyed.</span>
<span class="cm">         */</span>
        <span class="n">amps_client_destroy</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* AMPS applications communicate with the AMPS server by sending and</span>
<span class="cm">     * receiving messages. A logon command, like any other command, is</span>
<span class="cm">     * simply a message to AMPS.</span>
<span class="cm">     *</span>
<span class="cm">     * Instead of calling a function that assembles</span>
<span class="cm">     * and sends the logon command, we construct the command ourselves.</span>
<span class="cm">     *</span>
<span class="cm">     * The amps_message_create function creates a message and returns</span>
<span class="cm">     * an opaque handle to the message. In this example, we create</span>
<span class="cm">     * the message that we will use to send a logon command to AMPS.</span>
<span class="cm">     * When a message is created, the AMPS C client allocates resources</span>
<span class="cm">     * that must be freed by a corresponding call to the</span>
<span class="cm">     * amps_message_destroy function.</span>
<span class="cm">     *</span>
<span class="cm">     * Notice that the function uses information from</span>
<span class="cm">     * the connected client handle to construct the correct</span>
<span class="cm">     * message for the protocol the connection uses.</span>
<span class="cm">     */</span>
    <span class="n">logon_command</span> <span class="o">=</span> <span class="n">amps_message_create</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>

    <span class="cm">/* When a message is created in the AMPS C client, the message</span>
<span class="cm">     * contains no information at all. To make the message a logon</span>
<span class="cm">     * command, we need to set  the command type to &quot;logon&quot;.</span>
<span class="cm">     *</span>
<span class="cm">     * The C client provides a number of functions to assist in</span>
<span class="cm">     * interacting with the data and fields of a message. In this</span>
<span class="cm">     * example _nts functions are used, which allow for quick population</span>
<span class="cm">     * of messages fields and data with C-style null-terminated strings.</span>
<span class="cm">     *</span>
<span class="cm">     * The next few lines add a minimal set of fields for the logon</span>
<span class="cm">     * command.</span>
<span class="cm">     *</span>
<span class="cm">     * See the AMPS Command Reference for the full set of header fields</span>
<span class="cm">     * supported.  For simplicity in this basic example, we set the smallest</span>
<span class="cm">     * number of fields possible. For example, this sample does not</span>
<span class="cm">     * provide a user name or password on the command, nor does the</span>
<span class="cm">     * command request an acknowledgment message. In this case, the</span>
<span class="cm">     * application relies on the fact that AMPS will disconnect the</span>
<span class="cm">     * client if the logon command fails (causing subsequent commands</span>
<span class="cm">     * to fail).</span>
<span class="cm">     *</span>
<span class="cm">     * Production applications should register a message handler, request</span>
<span class="cm">     * acknowledgments for each command, and take appropriate actions if the</span>
<span class="cm">     * command fails.</span>
<span class="cm">     *</span>
<span class="cm">     * Because we are passing string literals, we use the _nts variant of</span>
<span class="cm">     * amps_message_set_field_value. This variant accepts a NULL-terminated</span>
<span class="cm">     * string. Other variants of amps_message_set_field value accept a</span>
<span class="cm">     * length, for use with strings that are not guaranteed to be</span>
<span class="cm">     * null-terminated.</span>
<span class="cm">     */</span>

    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">AMPS_Command</span><span class="p">,</span> <span class="s">&quot;logon&quot;</span><span class="p">);</span>
    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">AMPS_ClientName</span><span class="p">,</span> <span class="n">clientName</span><span class="p">);</span>
    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">AMPS_MessageType</span><span class="p">,</span> <span class="s">&quot;json&quot;</span><span class="p">);</span>

    <span class="cm">/* Once the command is constructed, we send the message.</span>
<span class="cm">     *</span>
<span class="cm">     * All interaction with AMPS is asynchronous. This means that</span>
<span class="cm">     * the return from amps_client_send does not indicate the</span>
<span class="cm">     * result of the command that the application sent to AMPS. Instead, the</span>
<span class="cm">     * return value indicates whether the AMPS client was able to send the</span>
<span class="cm">     * command to AMPS.</span>
<span class="cm">     */</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">amps_client_send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">logon_command</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">AMPS_E_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">amps_client_get_error</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errorBuffer</span><span class="p">));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">);</span>
        <span class="cm">/* In the case of an error, the application needs to destroy</span>
<span class="cm">         * both the logon command and the client.</span>
<span class="cm">         */</span>
        <span class="n">amps_message_destroy</span><span class="p">(</span><span class="n">logon_command</span><span class="p">);</span>
        <span class="n">amps_client_destroy</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Free the resources associated with the logon_command message by</span>
<span class="cm">     * calling amps_message_destroy with the message.</span>
<span class="cm">     */</span>
    <span class="n">amps_message_destroy</span><span class="p">(</span><span class="n">logon_command</span><span class="p">);</span>

    <span class="cm">/* As with the logon command, we must construct a message</span>
<span class="cm">     * that contains a publish message. While the C++ client</span>
<span class="cm">     * constructs and sends the message for us, with the C client we construct</span>
<span class="cm">     * them ourselves. Note that this line also allocates resources that must</span>
<span class="cm">     * be freed by a corresponding amps_message_destroy function.</span>
<span class="cm">     */</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">amps_message_create</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>

    <span class="cm">/* These next few lines are responsible for setting the necessary fields</span>
<span class="cm">     * and data to construct a valid publish message for AMPS.</span>
<span class="cm">     *</span>
<span class="cm">     * As before, because this sample uses string literals, we use the</span>
<span class="cm">     * set_field variant that accepts a null-terminated string.</span>
<span class="cm">     */</span>
    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">AMPS_CommandId</span><span class="p">,</span> <span class="s">&quot;12345&quot;</span><span class="p">);</span>
    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">AMPS_Command</span><span class="p">,</span> <span class="s">&quot;publish&quot;</span><span class="p">);</span>
    <span class="n">amps_message_set_field_value_nts</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">AMPS_Topic</span><span class="p">,</span> <span class="s">&quot;messages&quot;</span><span class="p">);</span>
    <span class="n">amps_message_set_data_nts</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">message</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\&quot;</span><span class="s">HelloWorld</span><span class="se">\&quot;</span><span class="s">}&quot;</span><span class="p">);</span>

    <span class="cm">/* Once the message is constructed to our satisfaction, it is sent. As</span>
<span class="cm">     * with the logon command, AMPS processes the publish command asynchronously.</span>
<span class="cm">     * If an acknowledgment is requested, AMPS returns the acknowledgment</span>
<span class="cm">     * message in response to the publish command. Your application must</span>
<span class="cm">     * process that acknowledgment asynchronously.</span>
<span class="cm">     */</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">amps_client_send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">AMPS_E_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Any errors from sending the message are detected and</span>
<span class="cm">         * examined here</span>
<span class="cm">         */</span>
        <span class="n">amps_client_get_error</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errorBuffer</span><span class="p">));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;error sending: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorBuffer</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * As before, the application must destroy the message</span>
<span class="cm">         * and the client before returning the error result.</span>
<span class="cm">         */</span>
         <span class="n">amps_message_destroy</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
         <span class="n">amps_client_destroy</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
         <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*</span>
<span class="cm">     * Since the application, is done with the message,</span>
<span class="cm">     *  we must free it.</span>
<span class="cm">     *</span>
<span class="cm">     * If the application were going to send multiple publish commands,</span>
<span class="cm">     * it could reset the values in the message and reuse the same</span>
<span class="cm">     * message object.</span>
<span class="cm">     *</span>
<span class="cm">     */</span>

    <span class="n">amps_message_destroy</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * ... other processing here as needed ...</span>
<span class="cm">     */</span>

    <span class="cm">/* Free the remaining AMPS resources by</span>
<span class="cm">     * destroying the client.</span>
<span class="cm">     */</span>
    <span class="n">amps_client_destroy</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example 11.1:</strong> <em>Connecting and publishing a message in C</em></p>
<p>Structurally, the example in C and in C++ are similar. In the C program
more details are needed to form your program, and the messages that are sent
need to be constructed directly, instead of having portions of the message
already created.</p>
<p>With the C client, your application is responsible for forming commands to
AMPS, receiving the responses, and interpreting the results. As mentioned above,
the AMPS Command Reference contains detailed information on the headers
that need to be set for specific commands. The Command Cookbook in
<a class="reference internal" href="creating-commands.html#cpp-working-with-commands"><span class="std std-ref">10.  AMPS Programming: Working with Commands</span></a> contains information on how to set headers for commonly used AMPS commands.</p>
<div class="section" id="c-client-functionality">
<h2>C Client Functionality<a class="headerlink" href="#c-client-functionality" title="Permalink to this headline">Â¶</a></h2>
<p>The C client provides a very basic interface. The client allows you to:</p>
<ul class="simple">
<li>Connect to AMPS</li>
<li>Create commands to AMPS in the appropriate protocol format</li>
<li>Send commands to AMPS</li>
<li>Receive messages from AMPS</li>
<li>Retrieve headers and data from messages received from AMPS</li>
<li>Detect connection errors and respond as needed</li>
</ul>
<p>The C client does not include any more complex functionality. For example, the C++ client includes
the ability to automatically track multiple subscriptions and dispatch messages to different
callbacks for each subscription. With the C client, to support multiple subscriptions
your application must receive messages, interpret the headers, and dispatch to the
appropriate callback. Likewise, the C++ client includes support for reliable
publication, resumable subscriptions, automatic failover, automatic handling of AMPS
failure acknowledgments when sending a command, and so on. With the C client, your
application is responsible for implementing the equivalent functionality if it is
needed.</p>
</div>
<div class="section" id="when-to-use-the-c-client">
<h2>When to Use the C Client<a class="headerlink" href="#when-to-use-the-c-client" title="Permalink to this headline">Â¶</a></h2>
<p>For most applications, 60East recommends using the C++ client. The C client can be a good option
in cases where:</p>
<ul class="simple">
<li><em>The application is very simple</em>. For example, an application that simply
publishes messages without regard to whether the messages succeed or not
(such as an IoT application delivering near-real-time sensor data), or
an application that simply queries a SOW topic and writes to a file.</li>
<li><em>Environments where C++ is not available</em>.  For example, some embedded
environments do not support a C++ runtime.</li>
</ul>
<p>In cases where an application is written in C by convention or choice, but
would like to take advantage of C++ client functionality, a good
option can be to create a lightweight C-language wrapper around the
C++ client. 60East support can provide guidance and a sample of one
way to wrap the client for this option.</p>
</div>
<div class="section" id="error-handing-in-the-c-client">
<h2>Error Handing in the C Client<a class="headerlink" href="#error-handing-in-the-c-client" title="Permalink to this headline">Â¶</a></h2>
<p>Because the C client does not contain automatic acknowledgment processing,
most C programs have two distinct types of error handling:</p>
<ul>
<li><p class="first"><em>Detecting client-side failure</em>  Failure in the C client is indicated
with the return value from one of the C client functions. This covers
client-side failures only, such as attempting to send a message before
the client is connected, attempting to set a value on a field that
isn&#8217;t known to the AMPS C client, and so on. The application handles
these errors by checking the return value of the function call, and
taking whatever recovery steps are appropriate. When these errors
occur on a function call, this indicates an error in the local
application, not a response from the server.</p>
<p>For these failures, <code class="docutils literal"><span class="pre">amps_client_get_error</span></code> provides a way to
retrieve descriptive text for the error.</p>
</li>
<li><p class="first"><em>Detecting failure acknowledgments</em> Failure at the server is
indicated by the value <cite>failure</cite> in the <code class="docutils literal"><span class="pre">status</span></code> field of
an acknowledgment message returned from the server. If an application
needs to know the success or failure of a command from the server, the
application should request an acknowledgment and register a message handler
to receive the response from the server. For most commands, the application
would request a <code class="docutils literal"><span class="pre">processed</span></code> acknowledgment, which is returned when
the server has received the command and processed it for execution.
For publish commands, if the application needs to know that the
data was safely persisted, the application would request the
<code class="docutils literal"><span class="pre">persisted</span></code> acknowledgment. There are more details on
message acknowledgments in the <em>User Guide</em>, and the set of
acknowledgments for each command and the fields that AMPS provides
on the acknowledgment messages for each command are described
in the <em>Command Reference</em>.</p>
<p>For these failures, the <code class="docutils literal"><span class="pre">reason</span></code> field of the acknowledgment
contains a description of the failure.</p>
<p>Notice that the other clients handle the acknowledgments that indicate
success or failure transparently in most cases. As an example, the C++ client
requests a <code class="docutils literal"><span class="pre">processed</span></code> acknowledgment for a <code class="docutils literal"><span class="pre">subscribe</span></code> command,
and if that acknowledgment indicates that the command failed,
the C++ client inspects the <code class="docutils literal"><span class="pre">reason</span></code> for the failure and throws the
appropriate exception. With the C client, though, an application must
explicitly receive and handle acknowledgments from the server.</p>
<p>Not all applications require failure notifications from the server for all
commands. For example, systems that publish high-velocity ticker symbols or
real-time telemetry to AMPS may not bother to request <code class="docutils literal"><span class="pre">persisted</span></code>
acknowledgments for publish commands.  For these applications, it may not be
important to republish or report a failed update, since the information is out
of date by the time AMPS returns the acknowledgment message. In general,
60East recommends requesting an acknowledgment any time that your
application would take different steps if a command to the server fails, or
if logging that information would be important for monitoring.</p>
</li>
</ul>
</div>
<div class="section" id="c-client-samples">
<h2>C Client Samples<a class="headerlink" href="#c-client-samples" title="Permalink to this headline">Â¶</a></h2>
<p>The C/C++ client distribution contains the following sample to demonstrate using
the C client directly:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Sample Name</th>
<th class="head">Demonstrates</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">publish_and_sow.c</span></code></td>
<td><p class="first">Publishing messages to a
State-of-the-World topic and then
querying the contents of the topic.</p>
<p class="last">This sample also demonstrates how
to handle disconnection in the C client.</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, 60East Technologies, Inc.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>