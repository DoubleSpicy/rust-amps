
4. Subscriptions
=======================

Messages published to a topic on an AMPS server are available to other
clients via a subscription. Before messages can be received, a client
must subscribe to one or more topics on the AMPS server so that the
server will begin sending messages to the client. The server will
continue sending messages to the client until the client unsubscribes,
or the client disconnects. With content filtering, the AMPS server will
limit the messages sent only to those messages that match a
client-supplied filter. In this chapter, you will learn how to
subscribe, unsubscribe, and supply filters for messages using the AMPS
C/C++ client.

.. _#cpp-subscribing:

Subscribing
-----------

Subscribing to an AMPS topic takes place by calling
``Client.subscribe()``. Here is a short example showing the simplest way
to subscribe to a topic (error handling and connection details are
omitted for brevity):

.. code-block:: cpp

    Client client(...);
    client.connect(...);

    /* Here we have created or received a Client that is properly connected to an AMPS server. */
    client.logon();


    /* Here we subscribe to the topic messages. We do not provide a filter, so AMPS
     * does not content-filter the subscription. Although we don't use the object
     * explicitly here, the subscribe function returns a MessageStream object that we
     * iterate over. If, at any time, we no longer need to subscribe, we can break out
     * of the loop. When we break out of the loop, the MessageStream goes out of scope,
     * the MessageStream destructor runs, and the AMPS client sends an unsubscribe
     * command to AMPS.
     */
    for (auto message : client.subscribe("messages"))
    {          
        /* Within the body of the loop, we can process the message as we need to. In this
         * case, we simply print the contents of the message.
         */
        std :: cout << "Received message: " << message.getData () << std :: endl ;
    }                

**Example 4.1:** *Subscribing to a topic*

AMPS creates a background thread that receives messages and copies them
into a ``MessageStream`` that you iterate over. This means that the
client application as a whole can continue to receive messages while you
are doing processing work.

The simple method described above is provided for convenience. The AMPS
C++ client provides convenience methods for the most common form of the
AMPS commands. The client also provides an interface that allows you to
have precise control over the command. Using that interface, the example
above becomes:

.. code-block:: cpp

    Client client(...);
    client.connect(...);

    /* Here we have created or received a Client that is properly connected to an AMPS server. */
    client.logon();


    /* Here we subscribe to the topic messages. We do not provide a filter, so AMPS
     * does not content-filter the subscription. Although we don't use the object
     * explicitly here, the execute function returns a MessageStream object that we
     * iterate over. If, at any time, we no longer need to subscribe, we can break out
     * of the loop. When we break out of the loop, the MessageStream goes out of scope,
     * the MessageStream destructor runs, and the AMPS client sends an unsubscribe
     * command to AMPS.
     * 
     * Here we create a command object for the subscribe command, specifying the topic
     * messages.
     */
    for (auto message : ampsClient.execute(Command("subscribe").setTopic("messages")))
    {          
        std :: cout << "Received message: "<< message.getData () << std :: endl;
    }                
                
**Example 4.2:** *Subscribing to a topic*

The ``Command`` interface allows you to precisely customize the commands
you send to AMPS. For flexibility and ease of maintenance, 60East
recommends using the ``Command`` interface (rather than a named method)
for any command that will receive messages from AMPS. For publishing
messages, there can be a slight performance advantage to using the named
commands where possible.

Asynchronous Message Processing Interface
-------------------------------------------

The AMPS C++ client also supports an interface that allows you to
process messages asynchronously. In this case, you add a message handler
to the function call. The client returns the command ID of the subscribe
command once the server has acknowledged that the command has been
processed. As messages arrive, the client calls your message handler
directly on the background thread. This can be an advantage for some
applications. For example, if your application is highly multithreaded
and copies message data to a work queue processed by multiple threads,
there is usually a performance benefit to enqueuing work directly from
the background thread. See 
:ref:`Understanding Threading <#understanding-threading-section>` for a
discussion of threading considerations, including considerations for
message handlers.

Here is a short example (error handling and connection details are
omitted for brevity):

.. code-block:: cpp

    Client client(...);
    client.connect(...); 
    /* Here we have created or received a Client that is properly connected to an AMPS server. */


    client.logon();

    /* Here we create a subscription with the following parameters: 
     * command        : This is the AMPS Command object that contains the subscribe command.
     * MessageHandler : This is an AMPS MessageHandler object that refers to our message 
     *                  handling function myHandlerFunction. This function is
     *                  called on a background thread each time a message arrives. 
     *                  The second parameter, NULL, is passed as-is from the 
     *                  client.subscribe() call to the message handler with every message, 
     *                  allowing you to pass context about the subscription through to the 
     *                  message handler. 
     *
     * We create a command object for the subscribe command, specifying the topic
     * messages.
     */
    string subscriptionId = client.executeAsync(Command("subscribe").setTopic("messages"), 
                                                MessageHandler(myHandlerFunction, NULL));

    ...

    /* The myHandlerFunction is a global function that is invoked by AMPS whenever a
     * matching message is received. The first parameter, message, is a reference to an
     * AMPS Message object that contains the data and headers of the received message.
     * The second parameter, userData, is set to whatever value was provided in the
     * MessageHandler constructor -- NULL in this example.
     */
    void myHandlerFunction(const Message& message, void* userData)
    {
        std::cout << message.getData() << std::endl;
    }

**Example 4.3:** *Subscribing to a process with asynchronous processing*

.. caution::

    The AMPS client resets and reuses the message provided to this
    function between calls. This improves performance in the client,
    but means that if your handler function needs to preserve
    information contained within the message, you must copy the
    information rather than just saving the message object. Otherwise,
    the AMPS client cannot guarantee the state of the object or the
    contents of the object when your program goes to use it.

With newer compilers, you can use additional constructs to specify a
callback function. Recent improvements in C++ have added lambda
functions -- unnamed functions declared in-line that can refer to names
in the lexical scope of their creator. If available on your system, both
Standard C++ Library function objects and lambda functions may be used
as callbacks. Check ``functional.cpp`` in the samples directory for
numerous examples.

Using an Instance Method as a Message Handler
---------------------------------------------

One of the more common ways of providing a message handler is as an
instance method on an object that maintains message state. It's simple
to provide a handler with this capability, as shown below.

.. code-block:: cpp

    class StatefulHandler
    {
    private:
        std::string _handlerName;
    public:
        /* Construct the handler and save state. */
        StatefulHandler(const std::string& name) : _handlerName(name) {}

        /* Message handler method. */
        void operator()(const AMPS::Message & message)
        {
          std::cout << _handlerName << " got " << message.getData() << std::endl;
        }
    };

You can then provide an instance of the handler directly wherever a
message handler is required, as shown below:

.. code-block:: cpp

    client.subscribe(StatefulHandler("An instance"), "topic");          

.. _#understanding-threading-section:

.. include:: ./understanding-threading-section.inc
Unsubscribing
--------------

The AMPS server continues a subscription until the client explicitly ends
the subscription (that is, *unsubscribes*) or until the connection to
the client is closed.

With the synchronous interface, AMPS automatically unsubscribes to the
topic when the destructor for the ``MessageStream`` runs. You can also
explicitly call the ``close()`` method on the ``MessageStream`` object
to remove the subscription.

In the asynchronous interface, when a subscription is successfully made,
messages will begin flowing to the message handler, and the
``subscribe()`` or ``executeAsync()`` call will return a string for
the subscription id that serves as the identifier for this subscription. A
``Client`` can have any number of active subscriptions, and this
subscription id is how AMPS designates messages intended for this particular
subscription. To unsubscribe, we simply call ``unsubscribe`` with the 
subscription identifier:

.. code-block:: cpp

    Client client = ...;

    // Register asynchronous subscription
    std::string subId = client.executeAsync(
                             Command("subscribe").setTopic("messages"),
                             MessageHandler(myHandlerFunction, NULL));

    ... other work here ... 

    client.unsubscribe(subId);


**Example 4.4:** *Unsubscribing form a topic*

In this example, as in the previous section, we use the
``client.executeAsync()`` method to create a subscription to the
``messages`` topic. When our application is done listening to this
topic, it unsubscribes by passing in the ``subId`` returned by
``subscribe()``. After the subscription is removed, no more messages
will flow into our ``myHandlerFunction()``.

When an application calls ``unsubscribe()``, the client sends an
explicit ``unsubscribe`` command to AMPS. The AMPS server removes that
subscription from the set of subscriptions for the client, and stops
sending messages for that subscription. On the client side, the client
unregisters the subscription so that the ``MessageStream`` or
``MessageHandler`` for that subscription will no longer receive
messages for that subscription.

Notice that calling ``unsubscribe`` does not destroy messages that
the server has already sent to the client. If there are messages on
the way to the client for this subscription, the AMPS client must
consume those messages. If a ``LastChanceMessageHandler`` is registered,
the handler will receive the messages. Otherwise, they will be
discarded since no message handler matches the subscription ID on
the message.

Understanding messages
----------------------

So far, we have seen that subscribing to a topic involves working with
objects of ``AMPS::Message`` type. A ``Message`` represents a single
message to or from an AMPS server. Messages are received or sent for
every client/server operation in AMPS.

Header properties
-----------------

There are two parts of each message in AMPS: a set of headers that
provide metadata for the message, and the data that the message
contains. Every AMPS message has one or more header fields defined. The
precise headers present depend on the type and context of the message.
There are many possible fields in any given message, but only a few are
used for any given message. For each header field, the ``Message`` class
contains a distinct property that allows for retrieval and setting of
that field. For example, the ``Message.get_command_id()`` function
corresponds to the ``commandId`` header field, the
``Message.get_batch_size()`` function corresponds to the ``BatchSize``
header field, and so on. For more information on these header fields,
consult the *AMPS User Guide* and *AMPS Command Reference*.

To work with header fields, a ``Message`` contains
``getXxx()``/``setXxx()`` methods corresponding to the header fields.
60East does not recommend attempting to parse header fields from the raw
data of the message.

In AMPS, fields sometimes need to be set to a unique identifier value.
For example, when creating a new subscription, or sending a manually
constructed message, youâ€™ll need to assign a new unique identifier to
multiple fields such as ``CommandId`` and ``SubscriptionId``. For this
purpose, Message provides ``newXxx()`` methods for each field that generates
a new unique identifier and sets the field to that new value.

getData() method
^^^^^^^^^^^^^^^^^

Access to the data section of a message is provided via the
``getData()`` method. The ``data`` contains the unparsed data in the
message, returned as a series of bytes (a ``string`` or
``const char *``). Your application code parses and works with the data.

The AMPS C++ client contains a collection of helper classes for working
with message types that are specific to AMPS (for example, FIX, NVFIX,
and AMPS composite message types). For message types that are widely
used, such as JSON or XML, you can use whichever library you typically
use in your environment.

Advanced Messaging Support
---------------------------

The ``client.subscribe()`` function provides options for subscribing to
topics even when you do not know their exact names, and for providing a
filter that works on the server to limit the messages your application
must process.

Regex topics
------------

Regular Expression (Regex) Topics allow a regular expression to be
supplied in the place of a topic name. When you supply a regular
expression, it is as if a subscription is made to every topic that
matches your expression, including topics that do not yet exist at the
time of creating the subscription.

To use a regular expression, simply supply the regular expression in
place of the topic name in the ``subscribe()`` call. For example:

.. code-block:: cpp

    for (auto message : client.subscribe("client.*"))
    {
        /* receive messages for any topic that begins with 'client' */
        std::cout << "Received a message on topic '" << message.getTopic() << "' "
                  << "with the data: " << message.getData() << std::endl;
    }

**Example 4.5:** *Regex topic subscription*

In this example, messages on topics ``client`` and ``client1`` would
match the regular expression, and those messages will be returned by the
``MessageStream`` . As in the example, you can use the ``getTopic()``
method to determine the actual topic of the message sent to the lambda
function.

Content filtering
-----------------

One of the most powerful features of AMPS is content filtering. With
content filtering, filters based on message content are applied at the
server, so that your application and the network are not utilized by
messages that are uninteresting for your application. For example, if
your application is only displaying messages from a particular user, you
can send a content filter to the server so that only messages from that
particular user are sent to the client. The *AMPS User Guide* provides
full details on content filtering.

To apply a content filter to a subscription, simply pass it into the
``client.subscribe()`` call:

.. code-block:: cpp

    for (auto message : ampsClient.subscribe("messages", 0, "/sender = 'mom'"))
    {
        // process messages from mom
    }

**Example 4.6:** *Using content filters*

.. include:: ./content-filtering-info.inc
.. include:: ./filter-replace.inc
Next steps
-----------

At this point, you are able to build AMPS programs in C/C++ that publish
and subscribe to AMPS topics. For an AMPS application to be truly
robust, it needs to be able to handle the errors and disconnections that
occur in any distributed system. In the next chapter, we will take a
closer look at error handling and recovery, and how you can use it to
make your application ready for the real world.
